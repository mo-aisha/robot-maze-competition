#include <MazeRunner.h>
#include "Arduino.h"
#include <OrangutanMotors.h>
#include <OrangutanLCD.h>
#include <OrangutanBuzzer.h>
#include <OrangutanPushbuttons.h>
#include <Pololu3pi.h>
#include <PololuQTRSensors.h>
#include <OrangutanAnalog.h>
#include <OrangutanBuzzer.h>

/*
  __  __                 ____                              
 |  \/  | __ _ _______  |  _ \ _   _ _ __  _ __   ___ _ __ 
 | |\/| |/ _` |_  / _ \ | |_) | | | | '_ \| '_ \ / _ \ '__|
 | |  | | (_| |/ /  __/ |  _ <| |_| | | | | | | |  __/ |   
 |_|  |_|\__,_/___\___| |_| \_\\__,_|_| |_|_| |_|\___|_|   

 Event created by Aisha Animashaun, Andrew Gillard, Georgia Isaac, Jamie Tizzard and Manav Gupta

*/

MazeRunner bot(70, 80, 175, 260.0, 100, 200, 600);

unsigned int directions[3];
char path[100] = "";
unsigned char path_length = 0; // the length of the path

// Initializes the 3pi, displays a welcome message, calibrates, and
// plays the initial music.
void setup() {
 bot.setupRobot();
}

// This function decides which way to turn during the learning phase of
// maze solving.  It uses the variables found_left, found_straight, and
// found_right, which indicate whether there is an exit in each of the
// three directions, applying the "left hand on the wall" strategy.
char select_turn(unsigned char found_left, unsigned char found_straight, unsigned char found_right)
{
  // Make a decision about how to turn.  The following code
  // implements a left-hand-on-the-wall strategy, where we always
  // turn as far to the left as possible.
  if(found_left)
  return 'L';
  else if(found_straight)
  return 'S';
  else if(found_right)
  return 'R';
  else
  return 'B';
}

// Path simplification.  The strategy is that whenever we encounter a
// sequence xBx, we can simplify it by cutting out the dead end.  For
// example, LBL -> S, because a single S bypasses the dead end
// represented by LBL.
void simplify_path()
{
  // only simplify the path if the second-to-last turn was a 'B'
  if(path_length < 3 || path[path_length-2] != 'B')
  return;

  int total_angle = 0;
  int i;
  for(i=1;i<=3;i++)
  {
    switch(path[path_length-i])
    {
      case 'R':
      total_angle += 90;
      break;
      case 'L':
      total_angle += 270;
      break;
      case 'B':
      total_angle += 180;
      break;
    }
  }

  // Get the angle as a number between 0 and 360 degrees.
  total_angle = total_angle % 360;

  // Replace all of those turns with a single one.
  switch(total_angle)
  {
    case 0:
    path[path_length - 3] = 'S';
    break;
    case 90:
    path[path_length - 3] = 'R';
    break;
    case 180:
    path[path_length - 3] = 'B';
    break;
    case 270:
    path[path_length - 3] = 'L';
    break;
  }

  // The path is now two steps shorter.
  path_length -= 2;
}

// This function is called once.
void loop() {
  
  while(1){
    bot.straightUntilIntersection();
    bot.directionsAvailable(directions);

    unsigned char dir = select_turn(directions[0], directions[1], directions[2]);
    
    if(!bot.isEndOfMaze()){
      bot.turn(dir);
    }
    else{
      bot.stop();
      delay(1000);
      break;
    }

    path[path_length] = dir;
    path_length ++;

    simplify_path();
  }
  
  int count = 0;
  
  OrangutanLCD::clear;
  OrangutanLCD::print("Press B to re-run");
  
  while(!button_is_pressed(BUTTON_B)) {
  }
      
  delay(1000);
    
  while(1){
  
    bot.straightUntilIntersection();
    bot.directionsAvailable(directions);
     
    unsigned char dir = path[count];
    
    if(!bot.isEndOfMaze()){
        bot.turn(dir);
      } else {
        bot.stop();
        break;
    }
  
    count = count + 1;
  }
}
